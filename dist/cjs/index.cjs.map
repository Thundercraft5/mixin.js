{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/symbols.ts", "../../src/weakMaps.ts", "../../src/utils/hasMixinClass.ts", "../../src/utils/isMixinClass.ts", "../../src/utils/isMixinPrototype.ts", "../../src/utils/mixinInstanceOf.ts", "../../src/utils/makeInstanceOf.ts", "../../src/mixin.ts"],
  "sourcesContent": ["export * from \"./mixin\";\r\nexport { Mixin as default } from \"./mixin\";\r\nexport * from \"./symbols\";\r\nexport * from \"./types\";\r\nexport { hasMixinClass, isMixinClass, isMixinPrototype } from \"./utils\";", "import type { GenericMixin, Mixin } from \"./mixin\";\r\n\r\nexport const SymbolMixinConstruct = Symbol(\"Symbol.mixinConstruct\"),\r\n\tSymbolMixinClasses = Symbol(\"Symbol.mixinClasses\"),\r\n\tSymbolIsMixinClass = Symbol(\"Symbol.isMixinClass\"),\r\n\tSymbolIsMixinPrototype = Symbol(\"Symbol.isMixinPrototype\");\r\n\r\ndefineSymbol(SymbolMixinConstruct);\r\ndefineSymbol(SymbolIsMixinClass);\r\ndefineSymbol(SymbolIsMixinPrototype);\r\ndefineSymbol(SymbolMixinClasses);\r\n\r\nfunction defineSymbol(symbol: symbol) {\r\n\tconst property = symbol.description?.split(\".\")[1];\r\n\r\n\treturn property\r\n\t\t? (Object.defineProperty(Symbol, property, {\r\n\t\t\tvalue: symbol,\r\n\t\t\tconfigurable: false,\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: false,\r\n\t\t}), symbol)\r\n\t\t: symbol;\r\n}\r\n\r\ndeclare global {\r\n\tinterface SymbolConstructor {\r\n\t\t/**\r\n\t\t * A method that defines a constructor function that is called when this class is instantiated as a mixin. Called by {@linkcode Mixin} and {@linkcode GenericMixin} statically.\r\n\t\t */\r\n\t\treadonly mixinConstruct: typeof SymbolMixinConstruct;\r\n\r\n\t\t/**\r\n\t\t * A property that contains a list of mixins that were added to the base class.\r\n\t\t */\r\n\t\treadonly mixinClasses: typeof SymbolMixinClasses;\r\n\r\n\t\t/**\r\n\t\t * Denotes if the object is a special mixin class.\r\n\t\t */\r\n\t\treadonly isMixinClass: typeof SymbolIsMixinClass;\r\n\r\n\t\t/**\r\n\t\t * Denotes if the object is a special mixin prototype of a mixin class.\r\n\t\t */\r\n\t\treadonly isMixinPrototype: typeof SymbolIsMixinPrototype;\r\n\t}\r\n}", "export const\r\n\t/** Stores weak references between the mixin class/mixin class prototype and thier mixins.  */\r\n\tmixinClassMap = new WeakMap<object, Set<object>>(),\r\n\tmixinPrototypeMap = new WeakMap(),\r\n\tstaticMixinProtoMap = new WeakMap(),\r\n\tmixinProtoClassesMap = new WeakMap();", "import { mixinClassMap } from \"../weakMaps\";\r\nimport type { Class } from \"@thundercraft5/type-utils\";\r\n\r\nimport type { HasMixinClass, MixinClassObject } from \"../types\";\r\n\r\nexport default function hasMixinClass<M extends MixinClassObject, C extends Class>(MixinClass: M, Class: C): MixinClass is HasMixinClass<M, C> {\r\n\treturn mixinClassMap.get(MixinClass)!.has(Class);\r\n}", "/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\r\nimport { SymbolIsMixinClass } from \"../symbols\";\r\n\r\nimport type { Class } from \"@thundercraft5/type-utils\";\r\nimport type { IsMixinClassObject } from \"../types\";\r\n\r\n/**\r\n * Checks if {@linkcode Class} is a mixin class created from this library.\r\n * \r\n * @param Class \r\n * @returns A boolean if {@linkcode Class} is a mixin class\r\n */\r\nexport default function isMixinClass<C extends Class>(Class: C): Class is IsMixinClassObject<C> {\r\n\treturn typeof Class === \"object\" && Class !== null && SymbolIsMixinClass in Class!;\r\n}", "import { SymbolIsMixinClass } from \"../symbols\";\r\n\r\nimport type { IsMixinPrototype } from \"../types\";\r\n\r\n/**\r\n * Checks if {@linkcode prototype} is a mixin class prototype created from this library.\r\n * \r\n * @returns A boolean if {@linkcode prototype} is a mixin class prototype\r\n */\r\nexport default function isMixinPrototype<P extends object>(prototype: P): prototype is IsMixinPrototype<P> {\r\n\treturn typeof prototype === \"object\" && SymbolIsMixinClass in prototype;\r\n}", "import { mixinClassMap } from \"../weakMaps\";\r\n\r\nimport type { Class } from \"@thundercraft5/type-utils\";\r\n\r\nexport default function mixinInstanceOf<T extends Class>(target: any, type: T): target is InstanceType<T> {\r\n\tif (mixinClassMap.has(type) && mixinClassMap.get(type)!.has(target))\r\n\t\treturn true;\r\n\r\n\treturn false;\r\n}", "import mixinInstanceOf from \"./mixinInstanceOf\";\r\n\r\nimport type { Class } from \"@thundercraft5/type-utils\";\r\n\r\nexport default function makeInstanceOf<T extends Class>(type: T) {\r\n\treturn (target: any): target is InstanceType<T> => mixinInstanceOf(target, type);\r\n}", "/* eslint-disable @typescript-eslint/no-unsafe-member-access, func-style, unicorn/consistent-function-scoping, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-use-before-define, @typescript-eslint/no-redeclare */\nimport type { Class } from \"@thundercraft5/type-utils\";\nimport type { AbstractConstructor } from \"@thundercraft5/type-utils/constructors\";\n\nimport { SymbolIsMixinClass, SymbolIsMixinPrototype, SymbolMixinClasses, SymbolMixinConstruct } from \"./symbols\";\nimport type { GenericMixinClass, MixinClass } from \"./types\";\nimport { makeInstanceOf } from \"./utils\";\nimport { mixinClassMap, mixinPrototypeMap, staticMixinProtoMap } from \"./weakMaps\";\n\n/**\n * Checks if {@linkcode key} is a special key in a mixin class.\n * \n * @param key The key to check\n * @returns A boolean if the key is special\n */\nfunction isSpecialMixinKey(key: any): key is typeof Symbol.hasInstance | typeof SymbolIsMixinClass | \"prototype\" {\n\treturn key === SymbolIsMixinClass || key === Symbol.hasInstance || key === \"prototype\";\n}\n\n/**\n * Checks if {@linkcode key} is a special key in a mixin class prototype.\n * \n * @param key The key to check\n * @returns A boolean if the key is special\n */\nfunction isSpecialMixinProtoKey(key: any): key is typeof Symbol.toStringTag | typeof SymbolIsMixinPrototype | typeof SymbolMixinClasses {\n\treturn key === SymbolIsMixinPrototype || key === Symbol.toStringTag || key === SymbolMixinClasses;\n}\n\nfunction makeImmutableDescriptor<T>(value: T) {\n\treturn {\n\t\tvalue,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t} as const;\n}\n\n/** \n * Creates a mixin class with {@linkcode Base} as the base, with {@linkcode classes} as mixins.\n * Workaround for mixins with generic parameters.\n * \n * **Usage Notes**:\n * - Does not return the mixins from {@linkcode classes}, due to *direct* inheritance constraints of typescript.\n * - To achieve inheritance with generics, create a interface with the same signature as the class you are creating.\n * @see {Mixin}\n * @see {MixinConstructor}\n * @param Base The base class to extend\n * @param classes The classes to add to the base as mixins\n * @returns A class with {@linkcode Base} as the base class and {@linkcode classes} added as mixins\n */\nexport function GenericMixin<\n\tBase extends AbstractConstructor,\n\tClasses extends Class[] = [],\n>(Base: Base, ...classes: [...Classes]) {\n\treturn Mixin(Base, ...classes) as GenericMixinClass<Base, Classes>;\n}\n\n/**\n * Creates a mixin class for a given class as the base and additional classes as mixins.\n * \n * **Usage Notes:**\n * - Only the base class can be instantiated with generics. Use {@linkcode GenericMixin} and declaration merging to achieve generic instantiation for all classes.\n * \n * @see {MixinClass}\n * @see {GenericMixin}\n * @param Base The base class to extend\n * @param classes The classes to add to the base as mixins\n * @returns A class with {@linkcode Base} as the base class and {@linkcode classes} added as mixins\n */\nexport function Mixin<\n\tBase extends AbstractConstructor = typeof Object,\n\tClasses extends Class[] = [],\n>(Base: Base, ...classes: [...Classes]) {\n\tconst baseMixin = function() {},\n\t\tbasePrototype = Base.prototype,\n\t\tname = `${ Base.name } (${ classes.map(Class => Class.name).join(\", \") })`;\n\n\tbaseMixin.prototype = basePrototype;\n\tObject.defineProperty(baseMixin, \"name\", { value: name, enumerable: false });\n\n\tstaticMixinProtoMap.set(baseMixin, Base.prototype);\n\n\t/**\n\t * Create a mixin class, which is acts as a intermediary between the child and base class and mixins\n\t * Mixins have {@linkcode Symbol.hasInstance} method builtin to them alongside a property called Symbol.isMixinClass] that identifies it as a base mixin proxy\n\t */\n\tconst mixinClass = new Proxy(baseMixin, {\n\t\t\tget(target, key) {\n\t\t\t\tif (key === SymbolIsMixinClass)\n\t\t\t\t\treturn true;\n\t\t\t\tif (key === Symbol.hasInstance)\n\t\t\t\t\treturn instanceOf;\n\n\t\t\t\treturn key === \"prototype\"\n\t\t\t\t\t? mixinPrototypeObject\n\t\t\t\t\t: Reflect.get(target, key);\n\t\t\t},\n\n\t\t\tset(target, key, value) {\n\t\t\t\tif (isSpecialMixinKey(key))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn Reflect.set(target, key, value);\n\t\t\t},\n\n\t\t\thas(target, key) {\n\t\t\t\tif (isSpecialMixinKey(key))\n\t\t\t\t\treturn true;\n\n\t\t\t\treturn Reflect.has(target, key);\n\t\t\t},\n\n\t\t\tdeleteProperty(target, key) {\n\t\t\t\tif (isSpecialMixinKey(key))\n\t\t\t\t\tfalse;\n\n\t\t\t\treturn Reflect.deleteProperty(target, key);\n\t\t\t},\n\n\t\t\tdefineProperty(target, key, attributes) {\n\t\t\t\tif (isSpecialMixinKey(key))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn Reflect.defineProperty(target, key, attributes);\n\t\t\t},\n\n\t\t\tpreventExtensions(target) {\n\t\t\t\treturn Reflect.preventExtensions(target);\n\t\t\t},\n\n\t\t\tisExtensible(target) {\n\t\t\t\treturn Reflect.isExtensible(target);\n\t\t\t},\n\n\t\t\tgetPrototypeOf(target) {\n\t\t\t\treturn staticMixinProtoMap.get(target);\n\t\t\t},\n\n\t\t\tsetPrototypeOf(target, value) {\n\t\t\t\treturn Reflect.isExtensible(target)\n\t\t\t\t\t? (staticMixinProtoMap.set(target, value), true)\n\t\t\t\t\t: false;\n\t\t\t},\n\n\t\t\tgetOwnPropertyDescriptor(target, key) {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase \"prototype\": return makeImmutableDescriptor(mixinPrototypeObject);\n\t\t\t\t\tcase Symbol.hasInstance: return makeImmutableDescriptor(instanceOf);\n\t\t\t\t\tcase Symbol.isMixinClass: return makeImmutableDescriptor(true);\n\t\t\t\t}\n\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, key);\n\t\t\t},\n\n\t\t\t// Rename function name to display mixin names in call stacks\n\t\t\tconstruct: Object.defineProperty((target, args, newTarget) => {\n\t\t\t\tconst newObject: object = Reflect.construct(Base, args, newTarget),\n\t\t\t\t\tthisTargetStack = [newObject];\n\n\t\t\t\tfor (const Class of classes)\n\t\t\t\t\tif (SymbolMixinConstruct in Class && typeof Class[SymbolMixinConstruct] === \"function\") {\n\t\t\t\t\t\tconst result = Class[SymbolMixinConstruct]!.call(newObject, args);\n\n\t\t\t\t\t\tif (typeof result === \"object\" && result !== newObject)\n\t\t\t\t\t\t\tconsole.warn(`Mixin constructor of class \"${ Class.name }\" returned a different object than the one that was created via \"new\". This value will be overwritten by further mixin returns.`);\n\t\t\t\t\t\tif (typeof result === \"object\" && result != null)\n\t\t\t\t\t\t\tthisTargetStack.push(result);\n\t\t\t\t\t}\n\n\n\t\t\t\t// becomes the `this` of the constructed class\n\t\t\t\treturn newObject;\n\t\t\t}, \"name\", { value: `new ${ name }` }),\n\n\t\t\t// Rename function name to display mixin names in call stacks\n\t\t\tapply: Object.defineProperty(() => {\n\t\t\t\tthrow new TypeError(`Class constructor of mixin '${ name }' must be invoked with 'new'`);\n\t\t\t}, \"name\", { value: name }),\n\t\t}) as any as Class,\n\n\t\tbaseProtoObject = Object.create(basePrototype),\n\t\tinstanceOf = makeInstanceOf(mixinClass);\n\n\tmixinPrototypeMap.set(baseProtoObject, basePrototype);\n\t/** Mixin prototypes have a property called {@linkcode Symbol.isMixinPrototype} to indicate if they are mixin prototype proxies */\n\tconst mixinPrototypeObject = new Proxy(baseProtoObject, {\n\t\tget(target, key) {\n\t\t\tif (key === SymbolIsMixinPrototype)\n\t\t\t\treturn true;\n\t\t\tif (key === Symbol.toStringTag)\n\t\t\t\treturn Base.name ?? basePrototype[Symbol.toStringTag];\n\n\t\t\t// Properties on the mixin prototype object itself come before mixin properties\n\t\t\tif (Reflect.has(target, key))\n\t\t\t\treturn Reflect.get(target, key);\n\n\t\t\t// Mixin methods take precedence over base classes\n\t\t\tfor (const Class of mixinClassMap.get(target) as Set<Classes[number]>)\n\t\t\t\tif (Reflect.has(Class.prototype, key))\n\t\t\t\t\treturn Reflect.get(Class.prototype, key);\n\n\n\t\t\treturn undefined;\n\t\t},\n\n\t\tset(target, key, value) {\n\t\t\tif (isSpecialMixinProtoKey(key))\n\t\t\t\treturn false;\n\n\t\t\treturn Reflect.set(target, key, value);\n\t\t},\n\n\t\thas(target, key) {\n\t\t\tif (isSpecialMixinProtoKey(key))\n\t\t\t\treturn true;\n\n\t\t\t// Mixin methods take precedence over base classes\n\t\t\tfor (const Class of mixinClassMap.get(target) as Set<Classes[number]>)\n\t\t\t\tif (Reflect.has(Class.prototype, key))\n\t\t\t\t\treturn true;\n\n\n\t\t\treturn Reflect.has(target, key);\n\t\t},\n\n\t\tdefineProperty(target, key, attributes) {\n\t\t\tif (isSpecialMixinProtoKey(key))\n\t\t\t\treturn false;\n\n\t\t\treturn Reflect.defineProperty(target, key, attributes);\n\t\t},\n\n\t\tdeleteProperty(target, key) {\n\t\t\tif (isSpecialMixinProtoKey(key))\n\t\t\t\treturn false;\n\n\t\t\treturn Reflect.deleteProperty(target, key);\n\t\t},\n\n\t\tgetPrototypeOf(target) {\n\t\t\treturn mixinPrototypeMap.get(target);\n\t\t},\n\n\t\tsetPrototypeOf(target, value) {\n\t\t\treturn mixinPrototypeMap.set(target, value), true;\n\t\t},\n\n\t\tisExtensible(target) {\n\t\t\treturn Reflect.isExtensible(target);\n\t\t},\n\n\t\tpreventExtensions(target) {\n\t\t\treturn Reflect.preventExtensions(target);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, key) {\n\t\t\tswitch (key) {\n\t\t\t\tcase Symbol.toStringTag: return makeImmutableDescriptor(Base.name ?? basePrototype[Symbol.toStringTag]);\n\t\t\t}\n\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, key);\n\t\t},\n\t});\n\n\tmixinClassMap.set(baseMixin, new Set(classes));\n\tmixinClassMap.set(basePrototype, new Set(classes));\n\n\treturn mixinClass as MixinClass<Base, Classes>;\n}"],
  "mappings": "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",
  "names": []
}
